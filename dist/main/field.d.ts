import { BehaviorSubject } from "rxjs";
import { AttributeChangedCallback, ConnectedCallback, DatumType, FieldDataMapperInjector, FormControlBasicMetadata, FormControlData, FormController, FormControllerInjector, ImmutableFormController, K, ListenedAttributes, ListenerAccessor, ListenersCache, V } from "./interfaces";
import { Any } from "rx-store-types";
export declare class FormFieldComponent<F extends FormControlData, M extends Partial<Record<F[number]["field"], FormControlBasicMetadata>>, S extends string = string, N extends number = number> extends HTMLElement implements ConnectedCallback, FieldDataMapperInjector<F, N>, FormControllerInjector<F, M, S>, AttributeChangedCallback<HTMLElement, ListenedAttributes>, ListenerAccessor<F, M, S> {
    protected field?: F[N]["field"];
    protected type?: DatumType;
    protected keyboardEventMapper?: (ev: any) => F[N]["value"];
    protected changeEventMapper?: (ev: any) => F[N]["value"];
    protected formControllerEmitter: BehaviorSubject<FormController<F, M, S> | ImmutableFormController<F, M, S> | null>;
    protected directChildEmitter: BehaviorSubject<HTMLElement | null>;
    protected stopBinding?: () => void;
    protected listeners: WeakMap<Node, ListenersCache>;
    protected isValidDirectChild(target?: Node | null): target is HTMLElement;
    private getDataset;
    private reportMultiChildError;
    protected removeEventListeners(removed: Node): void;
    protected setDirectChildFromMutations(mutationList: MutationRecord[]): void;
    protected directChildIsTarget(): boolean | null;
    protected observer: MutationObserver;
    private getChangeFunction;
    protected attachChildEventListeners(current: Node | null, formController: FormController<F, M, S> | ImmutableFormController<F, M, S> | null): void;
    private getChangeObserver;
    getBindingListeners<E extends HTMLElement>(formController: FormController<F, M, S> | ImmutableFormController<F, M, S>, field: F[N]["field"], current?: E): {
        mouseover(): void;
        mouseleave(): void;
        focus(): void;
        blur(): void;
        keydown: (event: any) => void;
        change: (event: Any) => void;
        destruct: () => void;
    };
    private setInputDefault;
    private emitOnlyChildOnMount;
    protected attrSetter(target: HTMLElement): (k: string, v: any) => void;
    protected setField(field: F[N]["field"]): void;
    protected setDatumType(type: DatumType): void;
    protected setRequiredProperties(): void;
    setKeyboardEventMapperMapper(mapper: (ev: any) => F[N]["value"]): void;
    setChangeEventMapperMapper(mapper: (ev: any) => F[N]["value"]): void;
    setFormController(controller: FormController<F, M, S> | ImmutableFormController<F, M, S>): void;
    getField(): F[N]["field"] | undefined;
    getDatumType(): DatumType | undefined;
    connectedCallback(): void;
    attributeChangedCallback(key: K<HTMLElement & ListenedAttributes>, prev: V<HTMLElement & ListenedAttributes>, next: V<HTMLElement & ListenedAttributes>): void;
    static get observedAttributes(): string[];
}
